```@meta
CurrentModule = B0Map
```

# Local Fitting

The task of local data fitting not only relevant for obtaining (independent) local estimates, 
but also appears as an intermediate step in regularized approaches, such as [PHASER](@ref).

## Algorithm

In `B0Map`, local data fitting is accomplished by the routine [`local_fit`](@ref local_fit)

```@docs
local_fit
```

which works as follows

- Check, whether `fitopt.ϕ_rngs` is empty. (can be generated by `set_num_phases_intervals(fitopt, 0)`)
    * If yes, hold the local `fitpar.ϕ` fixed and determine `fitpar.R2s ∈ fitopt.R2s_rng` via a golden section search (GSS), which minimizes the local ``\chi^2``.
    * Otherwise:
        1. For each interval `ϕ_rng ∈ fitopt.ϕ_rngs`
            - Determine `ϕ_opt ∈ ϕ_rng` via GSS for fixed `R2s == 0`
            - Determine `R2s ∈ fitpar.R2s_rng` via GSS for fixed `ϕ_opt`.
            - Calculate the resulting ``\chi^2``.
        2. Take the best combination `ϕ_opt`, `R2s_opt` and store the result in `fitpar.ϕ` and `fitpar.R2s`, respectively.
- If `fitopt.optim == true`, perform a (constrained) nonlinear numerical two-dimensional minimization, with `[fitpar.ϕ`, `fitpar.R2s]` as starting points. (Currently based upon the LBFGS solver from the [Optim.jl](https://github.com/JuliaNLSolvers/Optim.jl) package.) For this to work, the GRE model must support (at least) linear partial derivatives.
- Finally, 
    * the linear VARPRO coefficient vectors ``\bm{c}`` are stored in `fitpar.c` and
    * the minimal ``\chi^2`` in `fitpar.χ2`.

## Example

Based upon the example in [General steps](@ref), the code is as simple as 

```@julia
# preparation steps to set up fitpar and fitopt, as described before
...

# call local fit routine
BM.local_fit(fitpar, fitopt)
```

## GSS

A generic golden section search (GSS) implementation (which can also be used independently) is provided
by the function

```@docs
GSS
```

