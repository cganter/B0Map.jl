var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = B0Map","category":"page"},{"location":"#B0Map","page":"Home","title":"B0Map","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for B0Map.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [B0Map]","category":"page"},{"location":"#B0Map.AbstractGREMultiEcho","page":"Home","title":"B0Map.AbstractGREMultiEcho","text":"AbstractGREMultiEcho{Ny,Nx,Nc,T}\n\nAbstract supertype of multi-echo GRE sequences\n\nType parameters\n\nNy::Int: Number of acquired data == number(echoes) * number(coils)\nNx::Int: Number of variable parameters x ⊆ {ϕ, R2s, ...} (relevant for optimization)\nNc::Int: Number of linear coefficients (e.g. number of coil elements)\nT::Union{Float64, ComplexF64}: acquired data type\n\n\n\n\n\n","category":"type"},{"location":"#B0Map.GREMultiEchoWF","page":"Home","title":"B0Map.GREMultiEchoWF","text":"VP4Optim model\n\nScope\n\nRF spoiled multi-echo GRE sequence\nWater-fat tissue model\n\nSpecifics\n\nWater and fat are constrained to have equal phase at zero echo time.\nSupport for multiple coil elements and coil noise covariance matrix.\nThe fat fraction can either be calculated to minimize the cost function    chi^2 for fixed ϕ and R2s (this is the default setting) or set manually.\n\n\n\n\n\n","category":"type"},{"location":"#B0Map.GREMultiEchoWF-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{Val{Ny}, Val{Nx}, Val{Nc}, Val{Nt}, Vararg{Any, 9}}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.GREMultiEchoWF","text":"GREMultiEchoWF(::Val{Ny}, ::Val{Nx}, ::Val{Nc}, ::Val{Nt}, ts, B0, ppm_fat, ampl_fat, \n    precession, x_sym, Δt, mode, cov_mat) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.GREMultiEchoWFFW","page":"Home","title":"B0Map.GREMultiEchoWFFW","text":"VP4Optim model\n\nScope\n\nRF spoiled multi-echo GRE sequence\nWater-fat tissue model\n\nSpecifics\n\nWater and fat are not constrained to have equal phase at zero echo time.\nSingle coil only\n\n\n\n\n\n","category":"type"},{"location":"#B0Map.GREMultiEchoWFFW-Union{Tuple{Nx}, Tuple{Ny}, Tuple{Val{Ny}, Val{Nx}, Vararg{Any, 7}}} where {Ny, Nx}","page":"Home","title":"B0Map.GREMultiEchoWFFW","text":"GREMultiEchoWFFW(::Val{Ny}, ::Val{Nx}, ts, B0, ppm_fat, ampl_fat, \n    precession, x_sym, Δt) where {Ny,Nx}\n\nAuxiliary function\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.GREMultiEchoWFRW","page":"Home","title":"B0Map.GREMultiEchoWFRW","text":"VP4Optim model\n\nScope\n\nRF spoiled multi-echo GRE sequence\nWater-fat tissue model\n\nSpecifics\n\nWater and fat components are described by real weights, multiplied with a common phase factor.\nSingle coil only.\nNo partial derivatives implemented\n\n\n\n\n\n","category":"type"},{"location":"#B0Map.GREMultiEchoWFRW-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{Val{Ny}, Val{Nx}, Val{Nc}, Val{Nt}, Vararg{Any, 7}}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.GREMultiEchoWFRW","text":"GREMultiEchoWFRW(::Val{Ny}, ::Val{Nx}, ::Val{Nc}, ::Val{Nt}, ts, B0, ppm_fat, ampl_fat,\nprecession, x_sym, Δt) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.B0_map_varpro-Tuple{Function, Any, Any, Any}","page":"Home","title":"B0Map.B0_map_varpro","text":"B0_map(ge_con::Function, geFW_con::Function, args, data, S, bs::BSmooth;\nλ_tikh=1e-6,\nn_ϕ_0=6,\nR2s_rng=(0.0, 1.0),\nabs_acc_R2s=1e-3,\nn_chunks=8Threads.nthreads())\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.GSS-Tuple{Function, Any, Any}","page":"Home","title":"B0Map.GSS","text":"GSS(fun::Function, var_rng; rel_acc=1e-4, abs_acc=nothing)\n\nSearch for minimum of given function with golden section search (GSS).\n\nReturns location of minimum with absolute accuracy abs_acc.\n\nArguments\n\nfun::Function: real valued function of a single real valued argument.\nvar_rng::T <: Union{Vector, Tuple}: search interval boundaries, length(var_rng) == 2\nrel_acc::Float64 = 1e-4: compute abs_acc = rel_acc * (var_rng[2] - var_rng[1]).\nabs_acc::T <: Union{Nothing, Float64} = nothing: Overrules rel_acc, if supplied.\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.GSS_fit_R2s-Tuple{B0Map.AbstractGREMultiEcho, Any, Any}","page":"Home","title":"B0Map.GSS_fit_R2s","text":"GSS_fit_R2s(gre::AbstractGREMultiEcho, ϕ, R2s_rng; R2s_acc=1e-4)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.GSS_fit_ϕ-Tuple{B0Map.AbstractGREMultiEcho, Any, Any}","page":"Home","title":"B0Map.GSS_fit_ϕ","text":"GSS_fit_ϕ(gre::AbstractGREMultiEcho, R2s, ϕ_rng; ϕ_acc=1e-4)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_A-Union{Tuple{B0Map.GREMultiEchoWFFW{Ny, Nx}}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx}","page":"Home","title":"B0Map.calc_A","text":"calc_A(gre::GREMultiEchoWFFW{Ny,Nx}) where {Ny,Nx}\n\nAuxiliary method\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_Bb-Tuple{B0Map.GREMultiEchoWFFW, Any}","page":"Home","title":"B0Map.calc_Bb","text":"calc_Bb(gre::GREMultiEchoWFFW, A)\n\nAuxiliary method\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_f_c_chunk-NTuple{8, Any}","page":"Home","title":"B0Map.calc_f_c_chunk","text":"calc_f_c_chunk(gre, cis_chunk, data, ϕ, R2s, f, c)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_∂Bb-Union{Tuple{Nsy}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}, StaticArraysCore.SVector{Nsy}}} where {Ny, Nx, Nc, Nt, Nsy}","page":"Home","title":"B0Map.calc_∂Bb","text":"calc_∂Bb(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}, sy::SVector{Nsy}) where {Ny,Nx,Nc,Nt,Nsy}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_∂Bb-Union{Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWFFW{Ny, Nx}, Any}} where {Ny, Nx}","page":"Home","title":"B0Map.calc_∂Bb","text":"calc_∂Bb(gre::GREMultiEchoWFFW{Ny,Nx}, A) where {Ny,Nx}\n\nAuxiliary method\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_∂f-Union{Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.calc_∂f","text":"calc_∂f(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_∂∂Bb-Union{Tuple{Nsy}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}, StaticArraysCore.SVector{Nsy}}} where {Ny, Nx, Nc, Nt, Nsy}","page":"Home","title":"B0Map.calc_∂∂Bb","text":"calc_∂∂Bb(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}, sy::SVector{Nsy}) where {Ny,Nx,Nc,Nt,Nsy}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_∂∂Bb-Union{Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWFFW{Ny, Nx}, Any}} where {Ny, Nx}","page":"Home","title":"B0Map.calc_∂∂Bb","text":"calc_∂∂Bb(gre::GREMultiEchoWFFW{Ny,Nx}, tA) where {Ny,Nx}\n\nAuxiliary method\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_∂∂f-Union{Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.calc_∂∂f","text":"calc_∂∂f(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.coil_sensitivities-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"B0Map.coil_sensitivities","text":"coil_sensitivities(gre::GREMultiEchoWF)\n\nCalculates and returns the coil sensitivities.\n\nRemarks\n\nIf the coil noise covariance matrix Psi differs from the unit matrix, the routine    VP4Optim.c does not return the actual coil sensitivities.\nOtherwise it does.\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.fatTrait-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"B0Map.fatTrait","text":"fatTrait(gre::GREMultiEchoWF)\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.fat_fraction-Tuple{B0Map.GREMultiEchoWFFW}","page":"Home","title":"B0Map.fat_fraction","text":"fat_fraction(gre::GREMultiEchoWFFW)\n\nCalculates and returns fat fraction.\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.fat_fraction-Tuple{B0Map.GREMultiEchoWFRW}","page":"Home","title":"B0Map.fat_fraction","text":"fat_fraction(gre::GREMultiEchoWFRW)\n\nReturns r_f  (r_w + r_f)\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.fat_fraction-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"B0Map.fat_fraction","text":"fat_fraction(gre::GREMultiEchoWF)\n\nJust returns the actual value of f, whether calculated automatically or set manually.\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.fit_chunk_GSS-NTuple{10, Any}","page":"Home","title":"B0Map.fit_chunk_GSS","text":"fit_chunk_GSS(gre, cis_chunk, data, ϕ_rngs, R2s_rng, ϕ_acc, R2s_acc, ϕ, R2s, χ2)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.fit_chunk_GSS-NTuple{8, Any}","page":"Home","title":"B0Map.fit_chunk_GSS","text":"fit_chunk_GSS(gre, cis_chunk, data, R2s_rng, R2s_acc, ϕ, R2s, χ2)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.fit_chunk_optim-NTuple{7, Any}","page":"Home","title":"B0Map.fit_chunk_optim","text":"fit_chunk_optim(gre, cis_chunk, data, R2s_rng, ϕ, R2s, χ2)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.greMultiEchoWF","page":"Home","title":"B0Map.greMultiEchoWF","text":"greMultiEchoWF(ts, B0, ppm_fat, ampl_fat, precession, mode=:auto_fat; \n    x_sym=nothing, Δt=nothing, n_coils=1, cov_mat=ones(ComplexF64,1,1))\n\nConstructor \n\nArguments\n\nts::Vector{Float64}: Echo times [ms]\nB0::Float64: Main field strength [T]\nppm_fat::Vector{Float64}: Chemical shift of fat peaks\nampl_fat::Vector{Float64}: relative fat peak amplitudes (all positive with sum(ampl_fat) ≈ 1)\nprecession::Symbol: Orientation of precession ∈ {:clockwise, :counterclockwise}\nmode::Symbol: By default (mode == :auto_fat) the fat fraction f is calculated automatically.   Alternatively (mode == :manual_fat), it can also be set manually.\nx_sym::Vector{Symbol}: Vector of variable parameters ∈ {:ϕ, :R2s}, default: [:ϕ, :R2s]\nΔt::Union{Float64, Nothing}: Allows to adjust the frequency bandwidth 2πΔt in case of    non-equidistant echoes. Default: Δt equals the average echo spacing.\nn_coils::Integer: Number of coil elements (default == 1). Note: n_coils == Nc\ncov_mat::AbstractMatrix: Coil noise covariance matrix, if available. Default: Nc x Nc unit matrix\n\n\n\n\n\n","category":"function"},{"location":"#B0Map.greMultiEchoWFFW-NTuple{5, Any}","page":"Home","title":"B0Map.greMultiEchoWFFW","text":"greMultiEchoWFFW(ts, B0, ppm_fat, ampl_fat, precession; x_sym=[:ϕ, :R2s], Δt=nothing)\n\nConstructor \n\nArguments\n\nts::Vector{Float64}: Echo times [ms]\nB0::Float64: Main field strength [T]\nppm_fat::Vector{Float64}: Chemical shift of fat peaks\nampl_fat::Vector{Float64}: relative fat peak amplitudes (all positive with sum(ampl_fat) ≈ 1)\nprecession::Symbol: Orientation of precession ∈ {:clockwise, :counterclockwise}\nx_sym::Vector{Symbol}: Vector of variable parameters ∈ {:ϕ, :R2s}, default: [:ϕ, :R2s]\nΔt::Union{Float64, Nothing}: Allows to adjust the frequency bandwidth 2πΔt in case of    non-equidistant echoes. Default: Δt equals the average echo spacing.\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.greMultiEchoWFRW-NTuple{5, Any}","page":"Home","title":"B0Map.greMultiEchoWFRW","text":"greMultiEchoWFRW(ts, B0, ppm_fat, ampl_fat, precession; x_sym=[:ϕ, :R2s], Δt=nothing)\n\nConstructor \n\nArguments\n\nts::Vector{Float64}: Echo times [ms]\nB0::Float64: Main field strength [T]\nppm_fat::Vector{Float64}: Chemical shift of fat peaks\nampl_fat::Vector{Float64}: relative fat peak amplitudes (all positive with sum(ampl_fat) ≈ 1)\nprecession::Symbol: Orientation of precession ∈ {:clockwise, :counterclockwise}\nmode::Symbol: By default (mode == :auto_fat) the fat fraction f is calculated automatically.   Alternatively (mode == :manual_fat), it can also be set manually.\nx_sym::Vector{Symbol}: Vector of variable parameters ∈ {:ϕ, :R2s}, default: [:ϕ, :R2s]\nΔt::Union{Float64, Nothing}: Allows to adjust the frequency bandwidth 2πΔt in case of    non-equidistant echoes. Default: Δt equals the average echo spacing.\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.update!-Union{Tuple{B0Map.GREMultiEchoWFRW{Ny, Nx, Nc, Nt}}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.update!","text":"update!(gre::GREMultiEchoWFRW{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.update!-Union{Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.update!","text":"update!(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.update_A!-Union{Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.update_A!","text":"update_A!(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.update_fat_fraction!-Tuple{B0Map.AutoFat, B0Map.GREMultiEchoWF}","page":"Home","title":"B0Map.update_fat_fraction!","text":"update_fat_fraction!(::AutoFat, gre::GREMultiEchoWF)\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.update_fat_fraction!-Tuple{B0Map.ManualFat, B0Map.GREMultiEchoWF}","page":"Home","title":"B0Map.update_fat_fraction!","text":"update_fat_fraction!(::ManualFat, ::GREMultiEchoWF)\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.∂Bb!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.AutoFat, B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.∂Bb!","text":"∂Bb!(::AutoFat, gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.∂Bb!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.ManualFat, B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.∂Bb!","text":"∂Bb!(::ManualFat, gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.∂∂Bb!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.AutoFat, B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.∂∂Bb!","text":"∂∂Bb!(::AutoFat, gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.∂∂Bb!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.ManualFat, B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.∂∂Bb!","text":"∂∂Bb!(::ManualFat, gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.A-Tuple{B0Map.GREMultiEchoWFFW}","page":"Home","title":"VP4Optim.A","text":"VP.A(gre::GREMultiEchoWFFW)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.Bb!-Tuple{B0Map.GREMultiEchoWFFW}","page":"Home","title":"VP4Optim.Bb!","text":"VP.Bb!(gre::GREMultiEchoWFFW)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.Bb!-Union{Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"VP4Optim.Bb!","text":"VP.Bb!(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.par_changed!-Tuple{B0Map.GREMultiEchoWFRW}","page":"Home","title":"VP4Optim.par_changed!","text":"VP.par_changed!(gre::GREMultiEchoWFRW)\n\nMethod described in VP4Optim TBW\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.par_changed!-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"VP4Optim.par_changed!","text":"VP.par_changed!(gre::GREMultiEchoWF)\n\nMethod described in VP4Optim TBW\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.set_data!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWFRW{Ny, Nx, Nc, Nt}, AbstractArray}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"VP4Optim.set_data!","text":"VP.set_data!(gre::GREMultiEchoWFRW{Ny,Nx,Nc,Nt}, data::AbstractArray) where {Ny,Nx,Nc,Nt}\n\nStores data\n\nArguments\n\ndata::AbstractArray: Complex data as a vector of length Ny/2.\n\nRemarks\n\nInput is transformed into a real vector and handed over to VP4Optim.y!.\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.set_data!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}, AbstractArray}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"VP4Optim.set_data!","text":"VP.set_data!(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}, data::AbstractArray) where {Ny,Nx,Nc,Nt}\n\nSets new data and transforms them, if necessary.\n\nArguments\n\ndata::AbstractArray: Complex data for all time points and coils. The elements in data   must be ordered such that the expression SMatrix{Nt,Nc}(data) produces the correct data matrix    y_jgamma.\n\nRemarks\n\nThe data are transformed based upon the coil noise covariance matrix, as described in the documentation.\nThis is followed by a call of VP4Optim.y! with the transformed data as arguments.\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.x_changed!-Tuple{B0Map.GREMultiEchoWFRW}","page":"Home","title":"VP4Optim.x_changed!","text":"VP.x_changed!(gre::GREMultiEchoWFRW)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.x_changed!-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"VP4Optim.x_changed!","text":"VP.x_changed!(gre::GREMultiEchoWF)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.y!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWFRW{Ny, Nx, Nc, Nt}, AbstractArray}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"VP4Optim.y!","text":"VP.y!(gre::GREMultiEchoWFRW{Ny,Nx,Nc,Nt}, new_y::AbstractArray) where {Ny,Nx,Nc,Nt}\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.y!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}, AbstractArray}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"VP4Optim.y!","text":"VP.y!(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}, new_y::AbstractArray) where {Ny,Nx,Nc,Nt}\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.y!-Union{Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWFFW{Ny, Nx}, AbstractArray}} where {Ny, Nx}","page":"Home","title":"VP4Optim.y!","text":"VP.y!(gre::GREMultiEchoWFFW{Ny,Nx}, new_y::AbstractArray) where {Ny,Nx}\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.y_model-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"VP4Optim.y_model","text":"VP.y_model(gre::GREMultiEchoWF)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.∂Bb!-Tuple{B0Map.GREMultiEchoWFFW}","page":"Home","title":"VP4Optim.∂Bb!","text":"VP.∂Bb!(gre::GREMultiEchoWFFW)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.∂Bb!-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"VP4Optim.∂Bb!","text":"VP.∂Bb!(gre::GREMultiEchoWF)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.∂∂Bb!-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"VP4Optim.∂∂Bb!","text":"VP.∂∂Bb!(gre::GREMultiEchoWF)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.∂∂Bb!-Union{Tuple{B0Map.GREMultiEchoWFFW{Ny, Nx}}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx}","page":"Home","title":"VP4Optim.∂∂Bb!","text":"VP.∂∂Bb!(gre::GREMultiEchoWFFW{Ny,Nx}) where {Ny,Nx}\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"}]
}
