var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = B0Map","category":"page"},{"location":"#B0Map","page":"Home","title":"B0Map","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for B0Map.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [B0Map]","category":"page"},{"location":"#B0Map.AbstractGREMultiEcho","page":"Home","title":"B0Map.AbstractGREMultiEcho","text":"AbstractGREMultiEcho{Ny,Nx,Nc,T}\n\nAbstract supertype of multi-echo GRE sequences\n\nType parameters\n\nNy::Int: Number of acquired data == number(echoes) * number(coils)\nNx::Int: Number of variable parameters x ⊆ {ϕ, R2s, ...} (relevant for optimization)\nNc::Int: Number of linear coefficients (e.g. number of coil elements)\nT::Union{Float64, ComplexF64}: acquired data type\n\n\n\n\n\n","category":"type"},{"location":"#B0Map.FitOpt","page":"Home","title":"B0Map.FitOpt","text":"Data structure holding the fit parameters.\n\nLocal Fit\n\nn_ϕ::Int: number of golden section search (GSS) intervals for the initial phase search (with R2s == 0).\nϕ_rngs::Array: GSS intervals, associated with n_ϕ.\nR2s_rng::Array: Search range for R2s.\nϕ_acc::Float64: Required GSS accuracy for ϕ_acc\nR2s_acc::Float64: Required GSS accuracy for R2s_acc\noptim::Bool: Non-linear optimiztion in addition to GSS? (Requires gradients to be implemented for the GRE model.)\n\nGeneral\n\nn_chunks::Int: Number of chunks to profit from multi-threaded execution.\n\nRemark\n\nUse ϕsearchintervals to modify n_ϕ, since only then ϕ_rngs will be set properly.\n\n\n\n\n\n","category":"type"},{"location":"#B0Map.FitPar","page":"Home","title":"B0Map.FitPar","text":"Data structure for fitting images.\n\nContent\n\nSpecifics of the GRE acquisition and signal/tissue model\nMask to specify ROI\nArrays for the fitted internal parameters ϕ and R2s\nArrays for the resulting linear coil-dependent coefficients c(ϕ, R2s)\nGoodness of fit\n\nScope\n\nLocal and non-local (regularized) fitting\n\n\n\n\n\n","category":"type"},{"location":"#B0Map.GREMultiEchoWF","page":"Home","title":"B0Map.GREMultiEchoWF","text":"VP4Optim model\n\nScope\n\nRF spoiled multi-echo GRE sequence\nWater-fat tissue model\n\nSpecifics\n\nWater and fat are constrained to have equal phase at zero echo time.\nSupport for multiple coil elements and coil noise covariance matrix.\nThe fat fraction can either be calculated to minimize the cost function    chi^2 for fixed ϕ and R2s (this is the default setting) or set manually.\n\n\n\n\n\n","category":"type"},{"location":"#B0Map.GREMultiEchoWF-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{Val{Ny}, Val{Nx}, Val{Nc}, Val{Nt}, Vararg{Any, 9}}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.GREMultiEchoWF","text":"GREMultiEchoWF(::Val{Ny}, ::Val{Nx}, ::Val{Nc}, ::Val{Nt}, ts, B0, ppm_fat, ampl_fat, \n    precession, x_sym, Δt, mode, cov_mat) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.GREMultiEchoWFFW","page":"Home","title":"B0Map.GREMultiEchoWFFW","text":"VP4Optim model\n\nScope\n\nRF spoiled multi-echo GRE sequence\nWater-fat tissue model\n\nSpecifics\n\nWater and fat are not constrained to have equal phase at zero echo time.\nSingle coil only\n\n\n\n\n\n","category":"type"},{"location":"#B0Map.GREMultiEchoWFFW-Union{Tuple{Nx}, Tuple{Ny}, Tuple{Val{Ny}, Val{Nx}, Vararg{Any, 7}}} where {Ny, Nx}","page":"Home","title":"B0Map.GREMultiEchoWFFW","text":"GREMultiEchoWFFW(::Val{Ny}, ::Val{Nx}, ts, B0, ppm_fat, ampl_fat, \n    precession, x_sym, Δt) where {Ny,Nx}\n\nAuxiliary function\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.GREMultiEchoWFRW","page":"Home","title":"B0Map.GREMultiEchoWFRW","text":"VP4Optim model\n\nScope\n\nRF spoiled multi-echo GRE sequence\nWater-fat tissue model\n\nSpecifics\n\nWater and fat components are described by real weights, multiplied with a common phase factor.\nSingle coil only.\nNo partial derivatives implemented\n\n\n\n\n\n","category":"type"},{"location":"#B0Map.GREMultiEchoWFRW-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{Val{Ny}, Val{Nx}, Val{Nc}, Val{Nt}, Vararg{Any, 7}}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.GREMultiEchoWFRW","text":"GREMultiEchoWFRW(::Val{Ny}, ::Val{Nx}, ::Val{Nc}, ::Val{Nt}, ts, B0, ppm_fat, ampl_fat,\nprecession, x_sym, Δt) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.GSS-Tuple{Function, Any, Any}","page":"Home","title":"B0Map.GSS","text":"GSS(fun::Function, var_rng, acc; show_all=false)\n\nSearch for minimum of given function fun with golden section search (GSS).\n\nArguments\n\nfun::Function: real valued function of a single real valued argument.\nvar_rng::T <: Union{Vector, Tuple}: search interval boundaries, length(var_rng) == 2\nacc::Float64: Required accuracy of location.\nshow_all::Bool: Also return visited locations and their values (default: false)\n\nOutput\n\nshow_all ? ((x_opt, fun(x_opt)), xs, fs) : (x_opt, fun(x_opt)), where\nx_opt is the location of the minimum with value fun(x_opt)\nxs::Vector{Float64} is the vector of all tested locations and fs = map(x -> fun(x), xs)\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.GSS_fit_R2s-Tuple{B0Map.AbstractGREMultiEcho, Any, Any, Any}","page":"Home","title":"B0Map.GSS_fit_R2s","text":"GSS_fit_R2s(gre::AbstractGREMultiEcho, ϕ, R2s_rng; R2s_acc=1e-4)\n\nCalculate the best R2s for given ϕ with GSS Auxiliary function\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.GSS_fit_ϕ-Tuple{B0Map.AbstractGREMultiEcho, Any, Any, Any}","page":"Home","title":"B0Map.GSS_fit_ϕ","text":"GSS_fit_ϕ(gre::AbstractGREMultiEcho, R2s, ϕ_rng; ϕ_acc=1e-4)\n\nAuxiliary function\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_A-Union{Tuple{B0Map.GREMultiEchoWFFW{Ny, Nx}}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx}","page":"Home","title":"B0Map.calc_A","text":"calc_A(gre::GREMultiEchoWFFW{Ny,Nx}) where {Ny,Nx}\n\nAuxiliary method\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_Bb-Tuple{B0Map.GREMultiEchoWFFW, Any}","page":"Home","title":"B0Map.calc_Bb","text":"calc_Bb(gre::GREMultiEchoWFFW, A)\n\nAuxiliary method\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_par-Union{Tuple{T}, Tuple{B0Map.FitPar{T}, B0Map.FitOpt, Function, AbstractArray}} where T<:B0Map.AbstractGREMultiEcho","page":"Home","title":"B0Map.calc_par","text":"calc_par(fitpar::FitPar{T}, parfun::Function, res::AbstractArray, n_chunks=8Threads.nthreads()) where {T<:AbstractGREMultiEcho}\n\nExtract model specific information and store it in array res.\n\nArguments\n\nfitpar::FitPar: Fit parameters\nfitopt::FitOpt: Fit options\nparfun::Function: Used to call parfun(gre::T) for each location in fitpar.S, based upon the local data and fit estimates. \nres::AbstractArray: Allocated space for the results (size(res) == size(fitpar.S)).\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_par_chunk-Tuple{B0Map.AbstractGREMultiEcho, B0Map.FitPar, Function, AbstractArray, Any}","page":"Home","title":"B0Map.calc_par_chunk","text":"calc_par_chunk(gre::AbstractGREMultiEcho, fitpar::FitPar, parfun::Function, res::AbstractArray, cis_chunk)\n\nAuxiliary function\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_∂Bb-Union{Tuple{Nsy}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}, StaticArraysCore.SVector{Nsy}}} where {Ny, Nx, Nc, Nt, Nsy}","page":"Home","title":"B0Map.calc_∂Bb","text":"calc_∂Bb(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}, sy::SVector{Nsy}) where {Ny,Nx,Nc,Nt,Nsy}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_∂Bb-Union{Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWFFW{Ny, Nx}, Any}} where {Ny, Nx}","page":"Home","title":"B0Map.calc_∂Bb","text":"calc_∂Bb(gre::GREMultiEchoWFFW{Ny,Nx}, A) where {Ny,Nx}\n\nAuxiliary method\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_∂f-Union{Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.calc_∂f","text":"calc_∂f(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_∂∂Bb-Union{Tuple{Nsy}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}, StaticArraysCore.SVector{Nsy}}} where {Ny, Nx, Nc, Nt, Nsy}","page":"Home","title":"B0Map.calc_∂∂Bb","text":"calc_∂∂Bb(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}, sy::SVector{Nsy}) where {Ny,Nx,Nc,Nt,Nsy}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_∂∂Bb-Union{Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWFFW{Ny, Nx}, Any}} where {Ny, Nx}","page":"Home","title":"B0Map.calc_∂∂Bb","text":"calc_∂∂Bb(gre::GREMultiEchoWFFW{Ny,Nx}, tA) where {Ny,Nx}\n\nAuxiliary method\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.calc_∂∂f-Union{Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.calc_∂∂f","text":"calc_∂∂f(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.coil_sensitivities-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"B0Map.coil_sensitivities","text":"coil_sensitivities(gre::GREMultiEchoWF)\n\nCalculates and returns the coil sensitivities.\n\nRemarks\n\nIf the coil noise covariance matrix Psi differs from the unit matrix, the routine    VP4Optim.c does not return the actual coil sensitivities.\nOtherwise it does.\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.fatTrait-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"B0Map.fatTrait","text":"fatTrait(gre::GREMultiEchoWF)\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.fat_fraction-Tuple{B0Map.GREMultiEchoWFFW}","page":"Home","title":"B0Map.fat_fraction","text":"fat_fraction(gre::GREMultiEchoWFFW)\n\nCalculates and returns fat fraction.\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.fat_fraction-Tuple{B0Map.GREMultiEchoWFRW}","page":"Home","title":"B0Map.fat_fraction","text":"fat_fraction(gre::GREMultiEchoWFRW)\n\nReturns r_f  (r_w + r_f)\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.fat_fraction-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"B0Map.fat_fraction","text":"fat_fraction(gre::GREMultiEchoWF)\n\nJust returns the actual value of f, whether calculated automatically or set manually.\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.fitOpt-Tuple{B0Map.AbstractGREMultiEcho}","page":"Home","title":"B0Map.fitOpt","text":"fitOpt(gre::AbstractGREMultiEcho)\n\nDefault constructor for FitOpt\n\nArguments\n\ngre::AbstractGREMultiEcho: Initialized structure with GRE sequence parameters and signal/tissue model.\n\nDefault values\n\nn_ϕ == 3\nϕ_rngs == ϕ_search_intervals(n_ϕ, gre.ϕ_scale)\nR2s_rng == [0.0, 1.0]\nϕ_acc == 1.e-4\nR2s_acc == 1.e-4\noptim == true\nn_chunks == 8Threads.nthreads()\n\nRemarks\n\ngre is only needed, if Δt != ΔTE (to define an effective bandwidth in case of non-equidistant echo times)\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.fitPar-Union{Tuple{T}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.AbstractGREMultiEcho{Ny, Nx, Nc, T}, AbstractArray, AbstractArray}} where {Ny, Nx, Nc, T}","page":"Home","title":"B0Map.fitPar","text":"fitPar(gre::AbstractGREMultiEcho{Ny,Nx,Nc,T}, data::AbstractArray, S::AbstractArray) where {Ny,Nx,Nc,T}\n\nConstructor for FitPar\n\nArguments\n\ngre::AbstractGREMultiEcho: Initialized structure with GRE sequence parameters and signal/tissue model.\ndata::AbstractArray: Complex multi-echo (if available also multi-coil) GRE data for each location.\nS::AbstractArray: Mask to specify ROI.\n\nRemarks\n\nsize(S) defines size and spatial dimensions (typically 2 or 3) of the data block.\nMandatory: size(data)[ndims(S)] == size(S)\nThe format of data must be such that VP4Optim.setdata!(gre, reshape(data, size(S)..., :)[ci,:]) works for any ci ∈ CartesianIndices(S)\nFor single-coil images, this means ndims(data) == ndims(S) + 1 with the last index enumerating the echoes.\nFor multi-coil data, we typically have ndims(data) == ndims(S) + 2 with the last but one index enumerating echo times and the last index enumerating the coils.\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.greMultiEchoWF","page":"Home","title":"B0Map.greMultiEchoWF","text":"greMultiEchoWF(ts, B0, ppm_fat, ampl_fat, precession, mode=:auto_fat; \n    x_sym=nothing, Δt=nothing, n_coils=1, cov_mat=ones(ComplexF64,1,1))\n\nConstructor \n\nArguments\n\nts::Vector{Float64}: Echo times [ms]\nB0::Float64: Main field strength [T]\nppm_fat::Vector{Float64}: Chemical shift of fat peaks\nampl_fat::Vector{Float64}: relative fat peak amplitudes (all positive with sum(ampl_fat) ≈ 1)\nprecession::Symbol: Orientation of precession ∈ {:clockwise, :counterclockwise}\nmode::Symbol: By default (mode == :auto_fat) the fat fraction f is calculated automatically.   Alternatively (mode == :manual_fat), it can also be set manually.\nx_sym::Vector{Symbol}: Vector of variable parameters ∈ {:ϕ, :R2s}, default: [:ϕ, :R2s]\nΔt::Union{Float64, Nothing}: Allows to adjust the frequency bandwidth 2πΔt in case of    non-equidistant echoes. Default: Δt equals the average echo spacing.\nn_coils::Integer: Number of coil elements (default == 1). Note: n_coils == Nc\ncov_mat::AbstractMatrix: Coil noise covariance matrix, if available. Default: Nc x Nc unit matrix\n\n\n\n\n\n","category":"function"},{"location":"#B0Map.greMultiEchoWFFW-NTuple{5, Any}","page":"Home","title":"B0Map.greMultiEchoWFFW","text":"greMultiEchoWFFW(ts, B0, ppm_fat, ampl_fat, precession; x_sym=[:ϕ, :R2s], Δt=nothing)\n\nConstructor \n\nArguments\n\nts::Vector{Float64}: Echo times [ms]\nB0::Float64: Main field strength [T]\nppm_fat::Vector{Float64}: Chemical shift of fat peaks\nampl_fat::Vector{Float64}: relative fat peak amplitudes (all positive with sum(ampl_fat) ≈ 1)\nprecession::Symbol: Orientation of precession ∈ {:clockwise, :counterclockwise}\nx_sym::Vector{Symbol}: Vector of variable parameters ∈ {:ϕ, :R2s}, default: [:ϕ, :R2s]\nΔt::Union{Float64, Nothing}: Allows to adjust the frequency bandwidth 2πΔt in case of    non-equidistant echoes. Default: Δt equals the average echo spacing.\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.greMultiEchoWFRW-NTuple{5, Any}","page":"Home","title":"B0Map.greMultiEchoWFRW","text":"greMultiEchoWFRW(ts, B0, ppm_fat, ampl_fat, precession; x_sym=[:ϕ, :R2s], Δt=nothing)\n\nConstructor \n\nArguments\n\nts::Vector{Float64}: Echo times [ms]\nB0::Float64: Main field strength [T]\nppm_fat::Vector{Float64}: Chemical shift of fat peaks\nampl_fat::Vector{Float64}: relative fat peak amplitudes (all positive with sum(ampl_fat) ≈ 1)\nprecession::Symbol: Orientation of precession ∈ {:clockwise, :counterclockwise}\nmode::Symbol: By default (mode == :auto_fat) the fat fraction f is calculated automatically.   Alternatively (mode == :manual_fat), it can also be set manually.\nx_sym::Vector{Symbol}: Vector of variable parameters ∈ {:ϕ, :R2s}, default: [:ϕ, :R2s]\nΔt::Union{Float64, Nothing}: Allows to adjust the frequency bandwidth 2πΔt in case of    non-equidistant echoes. Default: Δt equals the average echo spacing.\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.local_fit-Union{Tuple{T}, Tuple{B0Map.FitPar{T}, B0Map.FitOpt}} where T<:B0Map.AbstractGREMultiEcho","page":"Home","title":"B0Map.local_fit","text":"local_fit(fitpar::FitPar{T}, fitopt::FitOpt) where {T<:AbstractGREMultiEcho}\n\nFit data to multi-echo GRE model locally.\n\nArguments\n\nfitpar::FitPar: Fit parameters (see FitPar and fitPar](@ref fitPar)).\nfitopt::FitOpt: Fit options (see FitOpt and fitOpt](@ref fitOpt)).\n\nRemarks\n\nFits fitpar.data to all points specified by fitpar.S.\nMakes use of multi-threading. Just start julia with as many workers as you like to use.\nIf isempty(fitopt.ϕ_rngs) == true, the GSS fit is only with respect to R2s, based upon the local phase, specified in fitpar.ϕ.\nOtherwise, for each interval in fitopt.ϕ_rngs a GSS search with respect to ϕ is performed, each time for R2s == 0. For each of these phases fixed, a subsequent GSS search with respect to R2s is performed. The combination [ϕ, R2s], which produces the best fit is selected.\nOptionally (fitopt.optim == true), for the best GSS estimate [ϕ, R2s] is refined with a nonlinear fit.\nThe final estimates [ϕ, R2s] are stored in fitpar, together with the linear coefficients VP4Optim.c and the goodness of fit VP4Optim.χ2.\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.local_fit_chunk-NTuple{4, Any}","page":"Home","title":"B0Map.local_fit_chunk","text":"local_fit_chunk(gre, fitpar, fitopt, cis_chunk)\n\nAuxiliary function\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.set_num_phase_intervals-Tuple{Any, Any, Any}","page":"Home","title":"B0Map.set_num_phase_intervals","text":"set_num_phase_intervals(fitpar, fitopt, n_ϕ)\n\nSets the GSS intervals for the initial ϕ search (with R2s == 0.0)\n\nArguments\n\nfitpar::FitPar: Fit parameters\nfitopt::FitOpt: Fit options\nn_ϕ: Number of search intervals\n\nRemarks\n\nResets field n_ϕ in fitopt and then calls ϕsearchintervals.\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.update!-Union{Tuple{B0Map.GREMultiEchoWFRW{Ny, Nx, Nc, Nt}}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.update!","text":"update!(gre::GREMultiEchoWFRW{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.update!-Union{Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.update!","text":"update!(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.update_A!-Union{Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.update_A!","text":"update_A!(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.update_fat_fraction!-Tuple{B0Map.AutoFat, B0Map.GREMultiEchoWF}","page":"Home","title":"B0Map.update_fat_fraction!","text":"update_fat_fraction!(::AutoFat, gre::GREMultiEchoWF)\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.update_fat_fraction!-Tuple{B0Map.ManualFat, B0Map.GREMultiEchoWF}","page":"Home","title":"B0Map.update_fat_fraction!","text":"update_fat_fraction!(::ManualFat, ::GREMultiEchoWF)\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.ϕ_search_intervals-Tuple{Any, Any}","page":"Home","title":"B0Map.ϕ_search_intervals","text":"ϕ_search_intervals(n_ϕ, ϕ_scale=1.0)\n\nCalulates the GSS intervals for the initial ϕ search (with R2s == 0.0)\n\nArguments\n\ngre::AbstractGREMultiEcho: Initialized structure with GRE sequence parameters and signal/tissue model.\nn_ϕ::Int: number of golden section search (GSS) intervals\n\nRemarks\n\nBackground: For non-equidistant echo times, the 2π-periodicity with respect to ϕ no longer holds.\ngre contains a field ϕ_scale == Δt / ΔTE to define an effective periodicity (or better search range) ϕ_scale * 2π via the optional parameter Δt. \nShould not be called directly. Use setnumphase_intervals instead.\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.∂Bb!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.AutoFat, B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.∂Bb!","text":"∂Bb!(::AutoFat, gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.∂Bb!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.ManualFat, B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.∂Bb!","text":"∂Bb!(::ManualFat, gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.∂∂Bb!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.AutoFat, B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.∂∂Bb!","text":"∂∂Bb!(::AutoFat, gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#B0Map.∂∂Bb!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.ManualFat, B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"B0Map.∂∂Bb!","text":"∂∂Bb!(::ManualFat, gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nAuxiliary routine\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.A-Tuple{B0Map.GREMultiEchoWFFW}","page":"Home","title":"VP4Optim.A","text":"VP.A(gre::GREMultiEchoWFFW)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.Bb!-Tuple{B0Map.GREMultiEchoWFFW}","page":"Home","title":"VP4Optim.Bb!","text":"VP.Bb!(gre::GREMultiEchoWFFW)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.Bb!-Union{Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}}, Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"VP4Optim.Bb!","text":"VP.Bb!(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}) where {Ny,Nx,Nc,Nt}\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.par_changed!-Tuple{B0Map.GREMultiEchoWFRW}","page":"Home","title":"VP4Optim.par_changed!","text":"VP.par_changed!(gre::GREMultiEchoWFRW)\n\nMethod described in VP4Optim TBW\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.par_changed!-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"VP4Optim.par_changed!","text":"VP.par_changed!(gre::GREMultiEchoWF)\n\nMethod described in VP4Optim TBW\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.set_data!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWFRW{Ny, Nx, Nc, Nt}, AbstractArray}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"VP4Optim.set_data!","text":"VP.set_data!(gre::GREMultiEchoWFRW{Ny,Nx,Nc,Nt}, data::AbstractArray) where {Ny,Nx,Nc,Nt}\n\nStores data\n\nArguments\n\ndata::AbstractArray: Complex data as a vector of length Ny/2.\n\nRemarks\n\nInput is transformed into a real vector and handed over to VP4Optim.y!.\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.set_data!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}, AbstractArray}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"VP4Optim.set_data!","text":"VP.set_data!(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}, data::AbstractArray) where {Ny,Nx,Nc,Nt}\n\nSets new data and transforms them, if necessary.\n\nArguments\n\ndata::AbstractArray: Complex data for all time points and coils. The elements in data   must be ordered such that the expression SMatrix{Nt,Nc}(data) produces the correct data matrix    y_jgamma.\n\nRemarks\n\nThe data are transformed based upon the coil noise covariance matrix, as described in the documentation.\nThis is followed by a call of VP4Optim.y! with the transformed data as arguments.\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.x_changed!-Tuple{B0Map.GREMultiEchoWFRW}","page":"Home","title":"VP4Optim.x_changed!","text":"VP.x_changed!(gre::GREMultiEchoWFRW)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.x_changed!-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"VP4Optim.x_changed!","text":"VP.x_changed!(gre::GREMultiEchoWF)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.y!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWFRW{Ny, Nx, Nc, Nt}, AbstractArray}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"VP4Optim.y!","text":"VP.y!(gre::GREMultiEchoWFRW{Ny,Nx,Nc,Nt}, new_y::AbstractArray) where {Ny,Nx,Nc,Nt}\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.y!-Union{Tuple{Nt}, Tuple{Nc}, Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWF{Ny, Nx, Nc, Nt}, AbstractArray}} where {Ny, Nx, Nc, Nt}","page":"Home","title":"VP4Optim.y!","text":"VP.y!(gre::GREMultiEchoWF{Ny,Nx,Nc,Nt}, new_y::AbstractArray) where {Ny,Nx,Nc,Nt}\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.y!-Union{Tuple{Nx}, Tuple{Ny}, Tuple{B0Map.GREMultiEchoWFFW{Ny, Nx}, AbstractArray}} where {Ny, Nx}","page":"Home","title":"VP4Optim.y!","text":"VP.y!(gre::GREMultiEchoWFFW{Ny,Nx}, new_y::AbstractArray) where {Ny,Nx}\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.y_model-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"VP4Optim.y_model","text":"VP.y_model(gre::GREMultiEchoWF)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.∂Bb!-Tuple{B0Map.GREMultiEchoWFFW}","page":"Home","title":"VP4Optim.∂Bb!","text":"VP.∂Bb!(gre::GREMultiEchoWFFW)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.∂Bb!-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"VP4Optim.∂Bb!","text":"VP.∂Bb!(gre::GREMultiEchoWF)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.∂∂Bb!-Tuple{B0Map.GREMultiEchoWF}","page":"Home","title":"VP4Optim.∂∂Bb!","text":"VP.∂∂Bb!(gre::GREMultiEchoWF)\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"},{"location":"#VP4Optim.∂∂Bb!-Union{Tuple{B0Map.GREMultiEchoWFFW{Ny, Nx}}, Tuple{Nx}, Tuple{Ny}} where {Ny, Nx}","page":"Home","title":"VP4Optim.∂∂Bb!","text":"VP.∂∂Bb!(gre::GREMultiEchoWFFW{Ny,Nx}) where {Ny,Nx}\n\nMethod described in VP4Optim\n\n\n\n\n\n","category":"method"}]
}
